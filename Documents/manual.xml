<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
"http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">
<book>
  <title>Veusz - a scientific plotting package</title>

  <bookinfo>
    <author>
      <firstname>Jeremy</firstname>

      <surname>Sanders</surname>

      <email>jeremy@jeremysanders.net</email>
    </author>

    <copyright>
      <year>2005</year>
    </copyright>

    <legalnotice>
      <para>This document is released under the GNU Free Documention
      Licence, Version 1.1 or any later version published by the Free
      Software Foundation; with no Invariant Sections, no Front-Cover
      Texts. and no Back-Cover Texts.</para>
    </legalnotice>
  </bookinfo>

  <!---------------------------------------------------------------->
  <chapter>
    <title>Introduction</title>

    <section>
      <title>Veusz</title>

      <para>Veusz is a scientific plotting package. It was written as
      I was dissatisfied with existing plotting packages as they were
      either old and unmaintained (like pgplot and qdp, which does not
      support postscript fonts), not free (like IDL or Matlab), or had
      user interfaces I do not appreciate (like gnuplot).</para>

      <para>Veusz is designed to be easily extensible, and is written
      in Python, a high level language (in the future it may be
      necessary to write some parts in another language for speed, but
      this will be kept to an absolute minimum). It is also designed
      in an object oriented fashion, where a document is built up by a
      number of widgets in a hierarchy. The advantage of using Python
      is that is is easy to allow the user to script Veusz using
      Python as a very powerful scripting language. Indeed, the
      saved file format is a Python script.</para>

      <para>The technologies behind Veusz include PyQt (a very easy to
      use Python interface to Qt, which is used for rendering and the
      graphical user interface, GUI) and numarray (a package for Python
      which makes the handling of large datasets easy).</para>

      <para>Veusz has two user interfaces: a graphical one which gives
      the user a relatively shallow learning curve, and a command line
      interface. The command line interface is also used by scripting
      and in the saved file format.</para>
    </section>

    <section>
      <title>Terminology</title>
      <para>Here I define some terminology for future use.</para>

      <section>
	<title>Widget</title>
	<para>A document and its graphs are built up from
	  widgets. These widgets can often by placed within each
	  other, depending on the type of the widget. A widget has
	  children, those widgets placed within it, and its
	  parent. The widgets have a number of different settings
	  which modify their behaviour. These include the font to be
	  used, the line thickness, and whether an axis is
	  logarithmic. In addition they have actions, which perform
	  some sort of activity on the widget or its children, like
	  "fit" for a fit widget.</para>
	
	<para>Widgets are specified with a "path", like a file in Unix
	or Windows. These can be relative to the current widget (do
	not start with a slash), or absolute (do not start with a
	slash). Examples of paths include, "/page1/graph1/x", "x" and
	".".</para>

	<para>The widget types include</para>
	
	<orderedlist>
	  <listitem>
	    <para>document - representing a complete document. A
	      document can contain pages. In addition it contains a
	      setting giving the page size for the document.</para>
	  </listitem>
	  
	  <listitem>
	    <para>page - representing a page in a document. One or
	      more graphs can be placed on a page, or a grid.</para>
	  </listitem>

	  <listitem>
	    <para>graph - defining an actual graph. A graph can be
	      placed on a page or within a grid. Contained within the
	      graph are its axes and plotters. A graph can be given a
	      background fill and a border if required. It also has a
	      margin, which specifies how far away from the edge of
	      its parent widget to plot the body of the graph.</para>

	    <para>A graph can contain several axes, at any position
	      on the plot. In addition a graph can use axes defined in
	      parent widgets, shared with other graphs.</para>

	    <para>More than one graph can be placed within in a
	      page. The margins can be adjusted so that they lie
	      within or besides each other.</para>
	  </listitem>

	  <listitem>
	    <para>grid - containing one or more graphs. A grid plots
	      graphs in a gridlike fashion. You can specify the number
	      of rows and columns, and the plots are automatically
	      replotted in the chosen arrangement. A grid can contain
	      graphs or axes. If an axis is placed in a grid, it can
	      be shared by the graphs in the grid.</para>
	  </listitem>

	  <listitem>
	    <para>axis - giving the scale for plotting data. An axis
	      translates the coordinates of the data to the screen. An
	      axis can be linear or logarithmic, it can have fixed
	      endpoints, or can automatically get them from the
	      plotted data. It also has settings for the axis labels
	      and lines, tick labels, and major and minor tick
	      marks.</para>

	    <para>An axis may be "horizontal" or "vertical" and can
	    appear anywhere on its parent graph or grid.</para>
	  </listitem>

	  <listitem>
	    <para>plotters - types of widgets which plot data or add
	      other things on a graph. There is no actual plotter
	      widget which can be added, but several types of plotters
	      listed below. Plotters typically take an axis as a
	      setting, which is the axis used to plot the data on the
	      graph (default x and y).</para>

	    <orderedlist>
	      <listitem>
		<para>function - a plotter which plots a function on
		  the graph. Functions can be functions of x or y
		  (parametric functions are not done yet!), and are
		  defined in Python expression syntax, which is very
		  close to most other languages. For example "3*x**2 +
		  2*x - 4". A number of functions are available
		  (e.g. sin, cos, tan, exp, log...). Technically,
		  Veusz imports the numarray package when evaluating,
		  so numarray functions are available.</para>

		<para>As well as the function setting, also settable
		  is the line type to plot the function, and the
		  number of steps to evaluate the function when
		  plotting. The function widget will also support
		  filled regions when implemented.</para>
	      </listitem>

	      <listitem>
		<para>xy - a plotter which plots scatter, line, or
		  stepped plots. This versatile plotter takes an x and
		  y dataset, and plots (optional) points, in a chosen
		  marker and colour, connecting them with (optional)
		  lines, and plotting (optional) error bars. An xy
		  plotter can also plot a stepped line, allowing
		  histograms to be plotted (note that it doesn't yet
		  do the binning of the data).</para>

		<para>The settings for the xy widget are the various
		  attibutes for the points, line and error bars, the
		  datasets to plot, and the axes to plot on.</para>
	      </listitem>

	      <listitem>
		<para>fit - fit a function to data. This plotter is
		  a like the function plotter, but allows fitting of
		  the function to data. This is achived by clicking on
		  a "fit" button, or using the "fit" action of the
		  widget. The fitter takes a function to fit
		  containing the unknowns, e.g. "a*x**2 + b*x + c",
		  and initial values for the variables (here a, b and
		  c). It then fits the data (note that at the moment,
		  the fit plotter fits all the data, not just the data
		  that can be seen on the graph) by minimising the
		  chi-squared.</para>

		<para>In order to fit properly, the y data (or x, if
		  fitting as a function of x) must have a properly
		  defined, preferably symmetric error. If there is
		  none, Veusz assumes the same fractional error
		  everywhere, or symmetrises asymmetric errors.</para>

		<para>Note that more work is required in this
		  widget, as if a parameter is not well defined by the
		  data, the matrix inversion in the fit will fail. In
		  addition Veusz does not supply estimates for the
		  errors or the final chi-squared in a machine
		  readable way.</para>
	      </listitem>

	      <listitem>
		<para>key - a box which describes the data
		  plotted. If a key is added to a plot, the key looks
		  for "key" settings of the other data plotted within
		  a graph. If there any it builds up a box containing
		  the symbol and line for the plotter, and the text in
		  the "key" setting of the widget. This allows a key
		  to be very easily added to a plot.</para>

		<para>The key may be placed in any of the corners of
		  the plot, in the centre, or manually
		  placed. Depending on the ordering of the widgets,
		  the key will be placed behind or on top of the
		  widget. The key can be filled and surrounded by a
		  box, or not filled or surrounded.</para>
	      </listitem>

	    </orderedlist>

	  </listitem>
	</orderedlist>

      </section>
      
      <section>
	<title>Measurements</title>

	<para>Distances, widths and lengths in Veusz can be specified
	in a number of different ways. These include absolute
	distances specified in physical units, e.g. 1cm, 0.05m, 10mm,
	5in, 10pt and 5", and relative units, which are relative to
	the largest dimension of the page, including 5%, 1/20,
	0.05.</para>
      </section>

      <section>
	<title>Settings</title>

	<para>The various settings of the widgets come in a number of
	types, including integers (e.g. 10), floats (e.g. 3.14), text
	("hi there!"), distances (see above), options ("horizontal" or
	"vertical" for axes).</para>

	<para>Veusz performs type checks on these parameters. If they
	are in the wrong format the control to edit the setting will
	turn red. In the command line, a TypeError exception is
	thrown.</para>

	<para>In the GUI, the current page is replotted if a setting
	is changed when enter is pressed or the user moves to another
	setting.</para>
      </section>

      <section>
	<title><anchor id="TextFonts" />Text</title>

	<para>Veusz understands a limited set of LaTeX-like formatting
	for text. There are some differences (for example, "10^23"
	puts the 2 and 3 into superscript), but it is fairly
	similar. Veusz supports superscripts ("^"), subscripts ("_"),
	brackets for applying attributes "{" and "}", greek letters
	("\alpha" to "\omega" and "\Alpha" to "\Omega"). For
	formatting, "\emph{hi}", "\italic{ho}" and "\textit{silver}"
	are for italic text, "\bold{foo}" and "\textbf{bar}" for bold
	and "\underline{yatta}" for underlined text. Also included are
	special symbols "\times", "\pm", "\deg", "\divide", "\dagger",
	"\ddagger", "\bullet", "\AA", "\sqrt", "\propto", "\infty",
	"\int", and "\sim".</para>

	<para>Veusz plots these symbols with Qt's unicode support. If
	your current font does not contain these symbols then you may
	get messy results. If you find this is the case, I highly
	recommend you to down load Microsoft's Corefonts (see <ulink
	url="http://corefonts.sourceforge.net/" />).</para>
      </section>

    </section>

    <section>
      <title>Installation</title>

      <para>To install Veusz you require the following:</para>
      <itemizedlist>

	<listitem>
	  <para>A recent version of Python. Checked versions include
	  2.3.3 and 2.4.</para>
	</listitem>

	<listitem>
	  <para>A recent version of numarray. Checked versions include
	  1.0.</para>
	</listitem>

	<listitem>
	  <para>A recent Qt and PyQt (which requires SIP). Checked
	  versions include Qt-3.3.3, sip-3.10.1, and PyQt-3.11.</para>
	</listitem>

	<listitem>
	  <para>Also recommended are Microsoft's Corefonts, which
	  include "Times New Roman" and "Arial". Veusz needs good
	  fonts in order to support special symbols. See <link
	  linkend="TextFonts">Text</link> for information.</para>
	</listitem>

      </itemizedlist>

      <para>You should start the script veusz.py from the main veusz
      directory</para>
    </section>
  </chapter>

  <!---------------------------------------------------------------->
  <chapter>
    <title>Reading data</title>
    <section>
      <title><anchor id="Descriptors" />Descriptors</title>
      <para>Foo bar</para>
    </section>
  </chapter>

  <!---------------------------------------------------------------->
  <chapter>
    <title>Command line interface</title>

    <section>
      <title>Introduction</title>

      <para>An alternative way to control Veusz is via its command
      line interface. As Veusz is a a Python application it uses
      Python as its scripting language. Therefore you can freely mix
      Veusz and Python commands on the command line. Veusz can also
      read in Python scripts from files (see the <link
      linkend="Command.Load">Load</link> command).</para>

      <para>When commands are entered in the command prompt in the
      Veusz window, Veusz supports a simplified command syntax, where
      brackets following commands names, and commas, can replaced by
      spaces in Veusz commands (not Python commands). For example,
      <command>Add('graph', name='foo')</command>, may be entered as
      <command>Add 'graph' name='foo'</command>.</para>

      <para>The command prompt supports history (use the up and down cursor
      keys to recall previous commands). </para>
    </section>

    <section>
      <title>Commands</title>
      
      <para>We list the allowed set of commands below</para>
      
      <section>
	<title><anchor id="Command.Action" />Action</title>
	
	<para><command>Action('actionname',
	widgetpath='.')</command></para>
	
	<para>Initiates the specified action on the widget given
	the action name. Actions perform certain automated
	routines. These include "fit" on a fit widget, and
	"zeroMargins" on grids.</para>
      </section>

      <section>
	<title><anchor id="Command.Add" />Add</title>
	
	<para><command>Add('widgettype', name='nameforwidget',
        autoadd=True, optionalargs)</command></para>
	
	<para>The Add command adds a graph into the current widget
        (See the <link linkend="Command.To">To</link> command to change
        the current position).</para>
	
	<para>The first argument is the type of widget to add. These
        include "graph", "page", "axis", "xy" and
        "grid". <command>name</command> is the name of the new widget
        (if not given, it will be generated from the type of the
        widget plus a number). The <command>autoadd</command>
        parameter if set, constructs the default sub-widgets this
        widget has (for example, axes in a graph).</para>
	
	<para>Optionally, default values for the graph settings may be
        given, for example <command>Add('axis', name='y',
        direction='vertical')</command>.</para>
	
	<para>Returns: Name of widget added.</para>
      </section>

      <section>
	<title><anchor id="Command.Export" />Export</title>

	<para><command>Export(filename, color=True,
      page=0)</command></para>

	<para>Export the page given to the filename given. The
      <command>filename</command> must end with the correct extension
      to get the right sort of output file. Currrenly supported
      extensions are '.eps' and '.png'. If <command>color</command> is
      True, then the output is in colour, else
      greyscale. <command>page</command> is the page number of the
      document to export (starting from 0 for the first page!).</para>
      </section>

      <section>
	<title><anchor id="Command.Get" />Get</title>

	<para><command>Get('settingpath')</command></para>

	<para>Returns: The value of the setting given by the path.</para>

	<informalexample>
	  <programlisting>
>>> Get('/page1/graph1/x/min')
'Auto'
</programlisting>
	</informalexample>
      </section>

      <section>
	<title><anchor id="Command.GetChildren" />GetChildren</title>

	<para><command>GetChildren(where='.')</command></para>

	<para>Returns: The names of the widgets which are children of
      the path given</para>
      </section>

      <section>
	<title><anchor id="Command.GetData" />GetData</title>
	<para><command>GetData(name)</command></para>

	<para>Returns: A tuple containing the datasets with the name
      given. The tuple is (data, symerr, negerr, poserr), with each a
      numarray of the same size or None. data are the values of the
      dataset, symerr are the symmetric errors (if set), negerr and
      poserr and negative and positive asymmetric errors (if
      set).</para>

	<informalexample>
	  <programlisting>
data = GetData('x')
SetData('x', data[0]*0.1, *data[1:])
</programlisting>
	</informalexample>
      </section>

      <section>
	<title><anchor id="Command.GetDatasets" />GetDatasets</title>

	<para><command>GetDatasets()</command></para>

	<para>Returns: The names of the datasets in the current
      document.</para>
      </section>

      <section>
	<title><anchor id="Command.GPL" />GPL</title>

	<para><command>GPL()</command></para>

	<para>Print out the GNU Public Licence, which Veusz is licenced
      under.</para>
      </section>

      <section>
	<title><anchor id="Command.ImportFile" />ImportFile</title>
	
	<para><command>ImportFile('filename',
	'descriptor')</command></para>
	
	<para>Imports data from a file. The arguments are the filename
	to load data from and the descriptor.</para>
	
	<para>The format of the descriptor is a list of variable names
        representing the columns of the data. For more information see
        <link linkend="Descriptors">Descriptors</link>.</para>

	<para>Returns: list of datasets imported.</para>
      </section>
      
      <section>
	<title><anchor id="Command.ImportString" />ImportString</title>
	
	<para><command>ImportString('descriptor',
	'data')</command></para>
	
	<para>Like, <link
	linkend="Command.ImportFile">ImportFile</link>, but loads the
	data from the specfied string rather than a file. This allows
	data to be easily embedded within a document. The data string is
	usually a multi-line Python string.</para>
	
	<para>Returns: list of datasets imported.</para>

	<informalexample>
	  <programlisting>
ImportString('x y', '''
1   2
2   5
3   10
''')
</programlisting>
	</informalexample>

      </section>
      
      <section>
	<title><anchor id="Command.List" />List</title>
	
	<para><command>List(where='.')</command></para>
	
	<para>List the widgets which are contained within the widget
      with the path given, the type of widgets, and a brief
      description.</para>
      </section>

      <section>
	<title><anchor id="Command.Load" />Load</title>
	
	<para><command>Load('filename.vsz')</command></para>
	
	<para>Loads the veusz script file given. The script file can
	be any Python code. The code is executed using the Veusz
	interpreter.</para>
	
	<para>Note: this command is only supported at the command line
	and not in a script. Scripts may use the python
	<command>execfile</command> function instead.</para>
      </section>
      
      <section>
	<title><anchor id="Command.Remove" />Remove</title>
	
	<para><command>Remove('widgetpath')</command></para>
	
	<para>Remove the widget selected using the path. See <link
	linkend="Command.To">To</link> for a description of the path
	syntax.</para>
      </section>

      <section>
	<title><anchor id="Command.Save" />Save</title>
	
	<para><command>Save('filename.vsz')</command></para>
	
	<para>Save the current document under the filename
	given.</para>
      </section>
      
      <section>
	<title><anchor id="Command.Set" />Set</title>
	
	<para><command>Set('settingpath', val)</command></para>
	
	<para>Set the setting given by the path to the value given. If
	the type of <command>val</command> is incorrect, an
	<command>InvalidType</command> exception is thrown. The path
	to the setting is the optional path to the widget the setting
	is contained within, an optional subsetting specifier, and the
	setting itself.</para>

	<informalexample>
	  <programlisting>
Set('page1/graph1/x/min', -10.)
</programlisting>
	</informalexample>

      </section>

      <section>
	<title><anchor id="Command.SetData" />Set</title>
	
	<para><command>SetData(name, val, symerr=None, negerr=None,
      poserr=None)</command></para>

	<para>Set the dataset name with the values given. If None is
      given for an item, it will be left blank. val is the actual
      data, symerr are the symmetric errors, negerr and poserr and the
      getative and positive asymmetric errors. The data can be given
      as lists or numarrays.</para>
      </section>
      
      <section>
	<title><anchor id="Command.SetVerbose" />SetVerbose</title>
	
	<para><command>SetVerbose(v=True)</command></para>
	
	<para>If <command>v</command> is <command>True</command>, then extra
	information is printed out by commands.</para>
      </section>
      
      <section>
	<title><anchor id="Command.To" />To</title>
	
	<para><command>To('widgetpath')</command></para>
	
	<para>The To command takes a path to a widget and moves to
        that widget. For example, this may be "/", the root widget,
        "graph1", "/page1/graph1/x", "../x". The syntax is designed to
        mimic Unix paths for files. "/" represents the base widget
        (where the pages reside), and ".." represents the widget next
        up the tree.</para>
	
      </section>
    </section>

  </chapter>
  
</book>
